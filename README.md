# Sweet Shop Management System

This project is a full-stack Sweet Shop Management System designed to manage sweets inventory and sales. It features a RESTful backend API and a modern single-page application (SPA) frontend.

---

## Project Overview

The application is built to demonstrate skills in API development, database management, frontend implementation, and modern development workflows.

### Key Features:
* **User Authentication**: Users can register and log in to access protected features.
* **Sweet Management**: A full set of API endpoints to add, view, update, and delete sweets.
* **Inventory Control**: Functionality to purchase sweets and restock inventory, with admin-only access for restocking.
* **Search and Filter**: The frontend allows users to search for sweets by name, category, or price range.
* **TDD Approach**: The backend was developed using a Test-Driven Development (TDD) approach, focusing on writing tests before implementation.

---

## Getting Started

### Prerequisites
* Node.js (LTS version recommended)
* A database (e.g., PostgreSQL, MongoDB)

### 1. Backend Setup

1.  Navigate to the `backend` directory.
2.  Install dependencies: `npm install`
3.  Configure your database connection in the `.env` file (create one if it doesn't exist).
4.  Run the server: `npm run dev`

### 2. Frontend Setup

1.  Navigate to the `frontend` directory.
2.  Install dependencies: `npm install`
3.  Start the development server: `npm run dev`

The frontend application will be available at `http://localhost:3000` (or the address specified in the terminal).

---

## My AI Usage

As per the project guidelines, I have leveraged AI tools to assist in the development process. This section details how I used these tools and my reflection on their impact.

### Tools Used
* **Google Gemini**: I used Gemini to brainstorm the structure of the API endpoints and to generate the initial draft of this README file.
* **[Add other AI tools you used, e.g., GitHub Copilot, ChatGPT]**: [Describe how you used them]

### How I Used AI
* **Brainstorming**: I used Gemini to get ideas on how to structure the RESTful API endpoints, ensuring they align with standard practices.
* **Boilerplate Generation**: I used an AI assistant to generate initial boilerplate code for controllers and services, which I then modified and built upon.
* **Debugging & Refinement**: I consulted with the AI to debug specific issues and to refactor parts of the code for better readability and performance.
* **Documentation**: The initial draft of this README file, including the project description and setup instructions, was generated with the help of an AI.

### Reflection
Using AI tools significantly accelerated the initial setup and scaffolding phases of the project. By automating repetitive tasks like boilerplate code generation, I could focus more on the core business logic and implementing the TDD workflow. It served as a valuable collaborative partner for brainstorming and debugging, allowing me to explore different solutions more efficiently. The process highlighted the importance of a developer's role in verifying, refining, and taking full ownership of the final code.

---

**Note:** This project adheres to the AI usage policy outlined in the project brief. Each commit where AI was used includes an AI as a co-author.


<img width="1905" height="859" alt="Screenshot 2025-09-21 010625" src="https://github.com/user-attachments/assets/791032f5-55c2-4b3e-8763-d4e26c8f8a16" />
<img width="1919" height="838" alt="Screenshot 2025-09-21 010616" src="https://github.com/user-attachments/assets/b6adf898-7530-4167-85d7-3c6016a425cb" />
<img width="1919" height="755" alt="Screenshot 2025-09-21 010601" src="https://github.com/user-attachments/assets/77b28a08-308b-4a6d-9a25-2960f498bea1" />
<img width="1870" height="846" alt="Screenshot 2025-09-21 010530" src="https://github.com/user-attachments/assets/24b24bed-bece-46bd-b928-d7d068e70633" />



